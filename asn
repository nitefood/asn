#!/usr/bin/env bash

########################################################################################
# -----------------------------------------------------------------------------------
#          ASN / IPv4 / IPv6 / Prefix / AS Path / Organization lookup tool
#
#               Project homepage: https://github.com/nitefood/asn
# -----------------------------------------------------------------------------------
#
# Usage:
#
#  (Launch the script without parameters or visit the project's homepage for usage info)
#
########################################################################################

WhoisASN(){
	found_asname=$(whois -h whois.cymru.com " -f -w -c -p -u as$1" | sed 's/\ *|\ */|/g' | awk -F '[|]' '{print $3}')
	if [ "$found_asname" = "NO_NAME" ]; then
		found_asname=""
	else
		pwhois_asn_info=$(whois -h whois.pwhois.org "registry source-as=$1" | grep -E "^Org-Name:|^Create-Date:")
		found_org=$(echo -e "$pwhois_asn_info" | grep -E "^Org-Name:" | cut -d ':' -f 2 | sed 's/^[ \t]*//')
		pwhois_createdate=$(echo -e "$pwhois_asn_info" | grep -E "^Create-Date:" | cut -d ':' -f 2- | sed 's/^[ \t]*//')
		found_createdate=$(date -d "$pwhois_createdate" "+%Y-%m-%d %H:%M:%S")
	fi
}

QueryRipestat(){
	StatusbarMessage "Retrieving BGP data for AS$1 ($found_asname)"
	# BGP routing stats
	ripestat_routing_data=$(curl -s "https://stat.ripe.net/data/routing-status/data.json?resource=AS$1&sourceapp=nitefood-asn")
	if [ -n "$ripestat_routing_data" ]; then
		ripestat_ipv4=$(echo -e "$ripestat_routing_data" | jq -r '.data.announced_space.v4.prefixes')
		ripestat_ipv6=$(echo -e "$ripestat_routing_data" | jq -r '.data.announced_space.v6.prefixes')
		ripestat_bgp=$(echo -e "$ripestat_routing_data" | jq -r '.data.observed_neighbours')
	fi
	# BGP neighbours list
	StatusbarMessage "Retrieving peering data for AS$1 ($found_asname)"
	ripestat_neighbours_data=$(curl -s "https://stat.ripe.net/data/asn-neighbours/data.json?resource=AS$1&sourceapp=nitefood-asn")
	upstream_peers=$(echo -e "$ripestat_neighbours_data" 	| jq -r '.data.neighbours | sort_by(.power) | reverse | .[] | select (.type=="left") | .asn')
	downstream_peers=$(echo -e "$ripestat_neighbours_data" 	| jq -r '.data.neighbours | sort_by(.power) | reverse | .[] | select (.type=="right") | .asn')
	uncertain_peers=$(echo -e "$ripestat_neighbours_data" 	| jq -r '.data.neighbours | sort_by(.power) | reverse | .[] | select (.type=="uncertain") | .asn')

	RESOLVE_COUNT=20
	OUTPUT_PEERS_PER_LINE=4

	# resolve AS names of the first n upstreams
	upstream_peercount=$(echo "$upstream_peers" | wc -l)
	resolved_upstream_peers=""
	count=0
	for peer in $(echo -e "$upstream_peers" | head -n $RESOLVE_COUNT); do
		(( count++ ))
		peername=$(curl -s "https://stat.ripe.net/data/as-overview/data.json?resource=AS$peer&sourceapp=nitefood-asn" | jq -r '.data.holder' | sed 's/ - .*//' )
		resolved_upstream_peers+="${greenbg} $peername ($peer) ${default} "
		[[ $(( count % OUTPUT_PEERS_PER_LINE )) -eq 0 ]] && resolved_upstream_peers+="\n"
	done
	# and add the remaining ones as AS numbers only
	unresolved_peercount=$(( upstream_peercount - RESOLVE_COUNT ))
	if [ "$unresolved_peercount" -ge 1 ]; then
		resolved_upstream_peers+="and more: "
		for peer in $(echo -e "$upstream_peers" | tail -n $unresolved_peercount ); do
			resolved_upstream_peers+="${green}${peer}${default} "
		done
	fi
	upstream_peers="$resolved_upstream_peers"

	# resolve AS names of the first n downstreams
	downstream_peercount=$(echo "$downstream_peers" | wc -l)
	resolved_downstream_peers=""
	count=0
	for peer in $(echo -e "$downstream_peers" | head -n $RESOLVE_COUNT); do
		(( count++ ))
		peername=$(curl -s "https://stat.ripe.net/data/as-overview/data.json?resource=AS$peer&sourceapp=nitefood-asn" | jq -r '.data.holder' | sed 's/ - .*//' )
		resolved_downstream_peers+="${yellowbg} $peername ($peer) ${default} "
		[[ $(( count % OUTPUT_PEERS_PER_LINE )) -eq 0 ]] && resolved_downstream_peers+="\n"
	done
	# and add the remaining ones as AS numbers only
	unresolved_peercount=$(( downstream_peercount - RESOLVE_COUNT ))
	if [ "$unresolved_peercount" -ge 1 ]; then
		resolved_downstream_peers+="and more: "
		for peer in $(echo -e "$downstream_peers" | tail -n $unresolved_peercount ); do
			resolved_downstream_peers+="${yellow}${peer}${default} "
		done
	fi
	downstream_peers="$resolved_downstream_peers"

	# resolve AS names of the first n uncertains
	uncertain_peercount=$(echo "$uncertain_peers" | wc -l)
	resolved_uncertain_peers=""
	count=0
	for peer in $(echo -e "$uncertain_peers" | head -n $RESOLVE_COUNT); do
		(( count++ ))
		peername=$(curl -s "https://stat.ripe.net/data/as-overview/data.json?resource=AS$peer&sourceapp=nitefood-asn" | jq -r '.data.holder' | sed 's/ - .*//' )
		resolved_uncertain_peers+="${lightgreybg} $peername ($peer) ${default} "
		[[ $(( count % OUTPUT_PEERS_PER_LINE )) -eq 0 ]] && resolved_uncertain_peers+="\n"
	done
	# and add the remaining ones as AS numbers only
	unresolved_peercount=$(( uncertain_peercount - RESOLVE_COUNT ))
	if [ "$unresolved_peercount" -ge 1 ]; then
		resolved_uncertain_peers+="and more: "
		for peer in $(echo -e "$uncertain_peers" | tail -n $unresolved_peercount ); do
			resolved_uncertain_peers+="${white}${peer}${default} "
		done
	fi
	uncertain_peers="$resolved_uncertain_peers"

	StatusbarMessage "Retrieving prefix allocations and announcements for AS$1 ($found_asname)"
	ipv4_inetnums=""
	ipv6_inetnums=""
	for prefix in $(curl -s "https://stat.ripe.net/data/announced-prefixes/data.json?resource=$1&sourceapp=nitefood-asn" | jq -r '.data.prefixes | .[] | .prefix'); do
		if [[ "$prefix" == *':'* ]]; then
			inet6nums=$(whois -h whois.ripe.net -- "-T inet6num -K -L --resource $prefix" | \
							grep -m2 inet6num | cut -d ':' -f 2- | sed 's/^[ \t]*//')
			for inet6num in $inet6nums; do
				# exclude RIR supernets
				prefix_size=$(echo "$inet6num" | cut -d '/' -f 2)
				[[ "$prefix_size" -lt 29 ]] && continue || ipv6_inetnums+="${inet6num}\n"
			done
		else
			ipv4_inetnums+=$(whois -h whois.ripe.net -- "-T inetnum -K -L --resource  $prefix" | \
							grep -m1 inetnum | cut -d ':' -f 2 | sed 's/^[ \t]*//' | xargs ipcalc -r | grep -v "deaggregate")
			ipv4_inetnums+="\n"
		fi
	done

	[[ -n "$ipv4_inetnums" ]] && ipv4_inetnums=$(echo -e "$ipv4_inetnums" | sort -u)
	[[ -n "$ipv6_inetnums" ]] && ipv6_inetnums=$(echo -e "$ipv6_inetnums" | sort -u)
	StatusbarMessage ""
}

RIPESuggestASN(){
	TRIM_WHITESPACES=false
	input="$1"
	while true; do
		StatusbarMessage "Retrieving suggested ASNs for ${bluebg}${input}${lightgreybg}"
		ripe_suggest_output=$(curl -s "https://stat.ripe.net/data/searchcomplete/data.json?resource=${input}&sourceapp=nitefood-asn" | \
								jq -r '.data.categories | .[] | select ( .category == "ASNs" ) | .suggestions[]')
		StatusbarMessage ""
		if [ -n "$ripe_suggest_output" ]; then
			found_suggestions=$(echo -e "$ripe_suggest_output" | jq -r '.description' | sort -u)
			for suggestion in $found_suggestions; do
				echo -e "\n${green}$suggestion${default}"
				for suggestion_asn in $(echo -e "$ripe_suggest_output" | jq -r 'select (.description=="'"$suggestion"'") | .value'); do
					echo -e "\t${yellow}$suggestion_asn${default}"
				done
			done
			echo ""
			return
		elif [ "$TRIM_WHITESPACES" = false ]; then
			TRIM_WHITESPACES=true
			oldinput="$input"
			# shellcheck disable=SC2001
			input=$(echo "$oldinput" | sed 's/[ \t]*//g')
			if [ "$input" = "$oldinput" ]; then
				echo -e "\n${redbg}No suggestions found${default}\n"
				return
			else
				continue
			fi
		else
			echo -e "\n${redbg}No suggestions found${default}\n"
			return
		fi
	done
}

WhoisIP(){
	full_whois_data=$(whois "$1")
	network_whois_data=$(echo -e "$full_whois_data" | grep -i -E "^netname:|^orgname:|^org-name:|^owner:|^descr:|^country:")
	abuse_whois_data=$(echo -e "$full_whois_data" | grep -E "^OrgAbuseEmail:|^abuse-c:|^% Abuse|^abuse-mailbox:")
	hostname=$(RdnsLookup "$1")
	abusecontacts=$(AbuseLookup "$abuse_whois_data")
	[[ -z "$hostname" ]] && hostname="-"
	if [ "$UNANNOUNCED_PREFIX" = false ]; then
		PwhoisLookup "$1"
	else
		# No data in the Team Cymru DB for this IP
		[[ -z "$network_whois_data" ]] && PrintErrorAndExit "Error: no data found for $input"
		found_asn="N/A (address not announced)"
		found_asname=""
		# check if it's an IXP, otherwise fall back to generic whois
		IsIXP "$1"
		if [ -n "$ixp_data" ]; then
			pwhois_org="${bluebg} IXP ${default} ${blue}${ixp_data}${default}"
		else
			pwhois_org=$(echo -e "$network_whois_data" | grep -i -E "^orgname:|^org-name:|^owner:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
		fi
		[[ -z "$pwhois_org" ]] && pwhois_org="N/A"
		found_route=$(echo -e "$network_whois_data" | grep -i -m2 -E "^descr:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do if [ -n "$line" ]; then echo -n "$line / "; fi; done | sed 's/ \/ $//')
		[[ -z "$found_route" ]] && found_route="N/A"
		pwhois_net=$(echo -e "$network_whois_data" | grep -i -E "^netname:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
		[[ -z "$pwhois_net" ]] && pwhois_net="N/A"
		if [ -n "$ixp_geo" ]; then
			pwhois_geo="$ixp_geo"
		else
			pwhois_geo=$(echo -e "$network_whois_data" | grep -m1 -i -E "^country:" | cut -d ':' -f 2 | sed 's/^[ \t]*//')
		fi
		[[ -z "$pwhois_geo" ]] && pwhois_geo="N/A"
	fi
	indent=$(( longest+4 ))
	if [ -n "$found_asname" ]; then
		output_asname="${green}($found_asname)"
	else
		output_asname=""
	fi
	rpki_output=""
	if [ "$RPKI_LOOKUP" = true ] && [ "$UNANNOUNCED_PREFIX" = false ]; then
		StatusbarMessage "Checking RPKI validity for ${bluebg}AS${found_asn}${lightgreybg} and prefix ${bluebg}${found_route}${lightgreybg}"
		RPKILookup "$found_asn" "$found_route"
		StatusbarMessage ""
		echo ""
	fi

	printf "${white}%${longest}s${default} ┌${bluebg}PTR${default} %s\n" "$1" "$hostname"
	printf "${white}%${indent}s${bluebg}ASN${default} ${red}%s %s${default}\n" "├" "$found_asn" "$output_asname"
	printf "${white}%${indent}s${bluebg}ORG${default} ${green}%s${default}\n" "├" "$pwhois_org"
	printf "${white}%${indent}s${bluebg}NET${default} ${yellow}%s (%s)${default}\n" "├" "$found_route" "$pwhois_net"
	printf "${white}%${indent}s${bluebg}ABU${default} ${blue}%s${default}\n" "├" "$abusecontacts"
	[[ -n "$rpki_output" ]] && printf "${white}%${indent}s${bluebg}ROA${default} %s\n" "├" "$rpki_output"
	[[ "$REPUTATION_LOOKUP" = true ]] && last_symbol="├" || last_symbol="└"
	printf "${white}%${indent}s${bluebg}GEO${default} ${magenta}%s${default}\n" "$last_symbol" "$pwhois_geo"
	[[ "$REPUTATION_LOOKUP" = false ]] && echo ""
}

LookupASNAndRouteFromIP(){
	found_asn=""
	found_route=""
	found_asname=""
	# TODO: consider switching to DNS lookups (ie dig instead of whois) to improve speed (esp. during traces)
	output=$(whois -h whois.cymru.com " -f -p -u $1" | sed 's/\ *|\ */|/g')
	found_asn=$(echo "$output" | awk -F'[|]' 'NR==1{print $1}')
	if [ "$found_asn" = "NA" ]; then
		# Team Cymru has no data for this IP. Inform WhoisIP() that we will have to fall back to a generic whois lookup.
		found_asn=""
		UNANNOUNCED_PREFIX=true
	else
		found_asname=$(echo "$output" | awk -F'[|]' 'NR==1{print $4}')
		found_route=$(echo "$output" | awk -F'[|]' 'NR==1{print $3}')
		UNANNOUNCED_PREFIX=false
	fi
}

ResolveHostnameToIPList(){
	raw_host_output=$(host "$1" 2>/dev/null)
	if echo -e "$raw_host_output" | grep -q "mail is handled"; then
		host_output=$(echo "$raw_host_output" | grep -B100 -A0 -m1 "mail is handled" | sed '$d')
	else
		host_output="$raw_host_output"
	fi
	ip=$(echo "$host_output" | grep -Eo "$ipv4v6regex")
	echo -e "$ip\n"
}

PrintUsage(){
	programname=$(basename "$0")
	BoxHeader "ASN / RPKI validity / BGP stats / IPv4v6 / Prefix / ASPath / Organization / IP reputation lookup tool"
	echo -e "\nUsage:\n\n  $programname ${green}[OPTIONS] ${blue}<TARGET>${default}\n\nOptions:" \
			"\n\n  ${green}-d, --detailed\n\t${default}Output detailed hop info during the AS path trace to the ${blue}TARGET${default}" \
			"\n\t(This option also enables RPKI validation/BGP hijacking detection for every hop)" \
			"\n\n  ${green}-n, --notrace\n\t${default}Disable tracing the AS path to the ${blue}TARGET${default}" \
			"\n\n  ${green}-s, --suggest\n\t${default}Lookup AS names and numbers matching ${blue}TARGET${default}" \
			"\n\n  ${green}-o, --organization\n\t${default}Force ${blue}TARGET${default} to be treated as an Organization Name" \
			"\n\nSupported targets:" \
			"\n\n  ${blue}<AS Number>${default}\n\tLookup matching and BGP announcements/neighbours data." \
			"\n\t(Supports \"as123\" and \"123\" formats - case insensitive)" \
			"\n\n  ${blue}<IPv4/IPv6>${default}\n\tLookup matching route(4/6), IP reputation and ASN data" \
			"\n\n  ${blue}<Prefix>${default}\n\tLookup matching ASN data" \
			"\n\n  ${blue}<host.name.tld>${default}\n\tLookup matching IP, route and ASN data. Supports multiple IPs - e.g. DNS RR" \
			"\n\n  ${blue}<Organization Name>${default}\n\tSearch by company name and lookup network ranges exported by (or related to) the company" \
			"\n\n\nProject homepage: ${yellow}https://github.com/nitefood/asn${default}\n"
}

PwhoisLookup(){
	pwhois_output=$(whois -h whois.pwhois.org "$1")
	if echo "$pwhois_output" | grep -vq "That IP address doesn't appear"; then
		pwhois_asn=$(echo "$pwhois_output" | grep -E "^Origin-AS" | cut -d ':' -f 2 | sed 's/^ //')
		pwhois_prefix=$(echo "$pwhois_output" | grep -E "^Prefix" | cut -d ':' -f 2 | sed 's/^ //')
		pwhois_asorg=$(echo "$pwhois_output" | grep -E "^AS-Org-Name" | cut -d ':' -f 2 | sed 's/^ //')
		# group all "Org-Name" fields on a single line
		pwhois_org=$(echo "$pwhois_output" | grep -E "^Org-Name" | cut -d ':' -f 2 | sed 's/^[ \t]*//g' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
		pwhois_net=$(echo "$pwhois_output" | grep -E "^Net-Name" | cut -d ':' -f 2 | sed 's/^ //')
		# if pWhois' Net-Name=Org-Name, then it's more useful to use AS-Org-Name instead of Org-Name (unless AS-Org-Name is empty)
		if [ -n "$pwhois_asorg" ] && [ "$pwhois_net" = "$pwhois_org" ]; then
			pwhois_org="$pwhois_asorg"
		fi
		if echo "$pwhois_output" | grep -q -E "^Geo-"; then
			# use "Geo-" fields in pWhois output
			cityfield="Geo-City"
			regionfield="Geo-Region"
			ccfield="Geo-CC"
		else
			cityfield="City"
			regionfield="Region"
			ccfield="Country-Code"
		fi
		pwhois_city=$(echo "$pwhois_output" | grep -m1 -E "^${cityfield}" | cut -d ':' -f 2 | sed 's/^ //')
		pwhois_region=$(echo "$pwhois_output" | grep -m1 -E "^${regionfield}" | cut -d ':' -f 2 | sed 's/^ //')
		pwhois_cc=$(echo "$pwhois_output" | grep -m1 -E "^${ccfield}" | cut -d ':' -f 2 | sed 's/^ //')
		if [ "$pwhois_city" = "NULL" ] || [ "$pwhois_region" = "NULL" ]; then
			pwhois_geo="$pwhois_cc"
		else
			pwhois_geo="$pwhois_city, $pwhois_region ($pwhois_cc)"
		fi
	else
		pwhois_output="";
	fi
}

RdnsLookup(){
	# reverse DNS (PTR) lookup.
	# get first lookup result only (in case of multiple PTR records) and remove trailing dot and CR (Cygwin) from hostname
	rdns=$(host "$1" | awk 'NR==1{sub(/\.\r?$/, "", $NF); print $NF}')
	if echo "$rdns" | grep -E -q "NXDOMAIN|SERVFAIL|^record$"; then rdns=""; fi
	echo "$rdns"
}

AbuseLookup(){
	abuselist=""
	for abusecontact in $(echo -e "$1" | grep -E "^OrgAbuseEmail:|^abuse-c:|^% Abuse|^abuse-mailbox:" | awk '{print $NF}' | tr -d \'); do
		if echo "$abusecontact" | grep -vq '@'; then
			# $abusecontact is not an email, try a whois lookup (it should be a handle)
			resolvedabuse=$(whois "$abusecontact" | grep -E -i "^abuse-mailbox:" | awk '{print $2}' | tr -d \')
			if [ -z "$resolvedabuse" ]; then
				# whois couldn't resolve the abuse handle. Try identifying the
				# original answering whois server and forcing a lookup on the same server
				original_whois_server=$(echo -e "$full_whois_data" | grep -E "^%.*whois\..*$" | awk 'NR==1 {print $NF}' | tr -d '[]')
				if [ -n "$original_whois_server" ]; then
					# original whois server found, try manually querying it with an extended set of grep patterns
					resolvedabuse=$(whois -h "$original_whois_server" "$abusecontact" | grep -E -m1 -i "^abuse-mailbox:|^e-mail:" | awk '{print $2}' | tr -d \')
				fi
			fi
			[[ -n "$resolvedabuse" ]] && abusecontact="$resolvedabuse"
		fi
		[[ -n "$abuselist" ]] && abuselist+="\n"
		abuselist+="$abusecontact"
	done

	if [ -n "$abuselist" ]; then
		echo -e "$abuselist" | tr " " "\n" | sort -u | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//'
	else
		echo "-"
	fi
}

HopPrint(){
	StatusbarMessage ""
	echo -e "$@"
	StatusbarMessage "Analyzing collected trace output to ${bluebg}${host_to_trace}${lightgreybg}"
}

TraceASPath(){
	starttime=$(date +%s)
	host_to_trace="$1"
	mtr_rounds=3
	WhatIsMyIP
	if [ "$DETAILED_TRACE" = true ]; then
		headermsg="Detailed trace to $userinput"
	else
		headermsg="Trace to $userinput"
	fi
	BoxHeader "$headermsg"
	echo ""
	StatusbarMessage "Collecting trace data to ${bluebg}${host_to_trace}${lightgreybg}"
	# cache the previously looked-up AS to save one lookup (target/last hop)
	if [ -n "$ixp_data" ]; then
		saved_asn="$ixp_data"
		saved_asname=""
		TARGET_IS_IXP=true
	else
		saved_asn="$found_asn"
		saved_asname="$found_asname"
		TARGET_IS_IXP=false
	fi
	# last_resolved_ip will save us one dns resolution (mtr returns the same last hop twice)
	last_resolved_ip=""
	privateregex='/(^127\.)|(^192\.168\.)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^::1$)|(^[fF][cCdD])/' # cheers https://stackoverflow.com/a/11327345/5377165
	# start the mtr trace in a bash coprocess to parse its output asynchronously
	coproc mtr -l -n -c"$mtr_rounds" "$host_to_trace"
	declare -a hostline_array
	declare -a dnsline_array
	declare -a pingline_array
	declare -a aspath_array
	# initialize the aspath array with our source AS
	# TODO: improve local WAN IPv6 ASN lookup (Cymru and pWhois sometimes fail to correctly retrieve matching prefix. Consider RIPEstat/direct whois?)
	LookupASNAndRouteFromIP "$local_wanip"
	if [ -z "$found_asn" ]; then
		found_asn="XXX"
		found_asname="(Unknown)"
	fi
	aspath_entry=$(printf "${red}%-6s ${green}%s${default}" "$found_asn" "$(echo "$found_asname" | cut -d ',' -f 1)" )
	aspath_array+=("$aspath_entry")
	while true; do
		# read mtr output from the bash coprocess pipe,
		# parsing raw mtr results beginning with :
		# - h ("hostline", or IPs)
		# - p ("pingline", or latencies)
		# see https://github.com/traviscross/mtr/blob/master/FORMATS
		if read -r -u "${COPROC[0]}" raw_mtr_line 2>/dev/null; then
			mtr_type=$(echo "$raw_mtr_line" | cut -d ' ' -f 1)
			mtr_hopnum=$(echo "$raw_mtr_line" | cut -d ' ' -f 2)
			mtr_data=$(echo "$raw_mtr_line" | cut -d ' ' -f 3)
			case "$mtr_type" in
				"h")
					# this is a hostline ($mtr_data is an IP address)
					hostline_array["$mtr_hopnum"]="$mtr_data"
					# do a reverse DNS lookup for the IP instead of relying on
					# mtr's dnsline results since it proved unreliable in dnsmasq scenarios.
					# See https://github.com/nitefood/asn/pull/3
					if [ "$mtr_data" != "$last_resolved_ip" ]; then
						last_resolved_ip="$mtr_data"
						hostname=$(RdnsLookup "$mtr_data")
						[[ -n "$hostname" ]] && dnsline_array["$mtr_hopnum"]="$hostname"
					fi
					;;
				"p")
					# this is a pingline ($mtr_data is a latency value in microseconds)
					cur_latency_sum=${pingline_array["$mtr_hopnum"]}
					pingline_array["$mtr_hopnum"]=$(echo "$cur_latency_sum $mtr_data" |\
					awk '{ sum = $1 + $2; printf ("%.1f\n", sum) }') # we store the total sum of reply times in the array, and will average it at display time
					;;
			esac
		else
			break
		fi
	done
	wait
	# mtr finished, analyze and output results
	HopPrint "$(printf "${lightgreybg}%4s %-72s%20s     %s    ${default}" "Hop" "IP Address" "Ping avg" "AS Information")"
	cur_hop_count=1
	last_hop=false
	for mtr_hopnum in "${!hostline_array[@]}"; do
		ixp_tag=""
		hop_asn=""
		hop_ip=${hostline_array[$mtr_hopnum]}
		# AS DATA lookup
		# check if IP is in private addressing space
		if [[ $hop_ip =~ $privateregex ]]; then
			asn_data="${white}(Private network)${default}"
			pwhois_output=""
		else
			# not a private address, try saving a lookup
			# (if $hop_ip = our target, ie we're at the last hop)
			if [ "$hop_ip" = "$host_to_trace" ]; then
				found_asn=$saved_asn
				found_asname=$saved_asname
				# avoid adding the same AS multiple times in a row in the summary path
				if [ "$TARGET_IS_IXP" = false ]; then
					# last hop, not an IXP
					aspath_entry=$(printf "${red}%-6s ${green}%s${default}" "${found_asn}" "$(echo "${found_asname}" | cut -d ',' -f 1)" )
					asn_data="${red}[AS$found_asn] ${green}$found_asname${default}"
				else
					# last hop, and is an IXP
					ixp_tag="${bluebg} IXP ${default}"
					asn_data="${ixp_tag} ${blue}${found_asn}${default}"
					aspath_entry=$(printf "%-6s  ${blue}%s${default}" "$ixp_tag" "$found_asn")
				fi
				if [[ ${#aspath_array[@]} -eq 0 ]] || [[ "${aspath_array[-1]}" != "$aspath_entry" ]]; then
					aspath_array+=("$aspath_entry")
				fi
				last_hop=true
			else
				# not the last hop. Lookup hop data
				LookupASNAndRouteFromIP "$hop_ip"
				if [ "$UNANNOUNCED_PREFIX" = true ]; then
					# No data in the Team Cymru DB. Check to see if the ip is assigned to an IXP, or fall back to generic whois.
					WhoisIP "$hop_ip" >/dev/null # don't display this, we're being parsed off-screen
					hop_asn="${red}N/A (address not announced)${default}"
					hop_org="$pwhois_org"
					hop_net="$pwhois_net"
					[[ -n "$found_route" ]] && hop_net+=" ($found_route)"
					hop_geo="$pwhois_geo"
					if [ -n "$ixp_data" ]; then
						# this hop is an IXP
						ixp_tag="${bluebg} IXP ${default}"
						asn_data="${ixp_tag} ${blue}${ixp_data}${default}"
						hop_org="${ixp_tag} ${blue}${ixp_data}${default}"
						aspath_entry=$(printf "%-6s  ${blue}%s${default}" "$ixp_tag" "$ixp_data")
						aspath_array+=("$aspath_entry")
					else
						# no data found and not an IXP hop, try retrieving relevant info from a generic whois lookup
						hop_whois_data=$(echo -e "$full_whois_data" | grep -i -m2 -E "^netname:|^orgname:|^org-name:|^descr:" | cut -d ':' -f 2 | sed 's/^[ \t]*//' | while read -r line; do echo -n "$line / "; done | sed 's/ \/ $//')
						if [ -z "$hop_whois_data" ]; then
							asn_data="${yellow}(No data)${default}"
						else
							asn_data="${yellow}(${hop_whois_data})${default}"
						fi
					fi
				else
					# lookup success
					asn_data="${red}[AS$found_asn] ${green}$found_asname${default}"
					# avoid adding the same AS multiple times in a row in the summary path
					aspath_entry=$(printf "${red}%-6s ${green}%s${default}" "$found_asn" "$(echo "$found_asname" | cut -d ',' -f 1)" )
					if [[ "${aspath_array[-1]}" != "$aspath_entry" ]]; then
						aspath_array+=("$aspath_entry")
					fi
				fi
			fi
			if [ "$DETAILED_TRACE" = "true" ] && [ "$UNANNOUNCED_PREFIX" = false ]; then
				# run a pWhois lookup if the hop is within an announced prefix,
				# otherwise we already have generic whois data stored (also in case of an IXP prefix)
				PwhoisLookup "$hop_ip"
				hop_asn="$pwhois_asn"
				hop_org="$pwhois_org"
				hop_net="$pwhois_net"
				hop_geo="$pwhois_geo"
				hop_prefix="$pwhois_prefix"
			fi
		fi

		# DNS data (only used if a hostname was resolved)
		if [ -n "${dnsline_array[$mtr_hopnum]}" ]; then
			saveip=$hop_ip
			hop_ip="${dnsline_array[$mtr_hopnum]} ($saveip)"
		fi

		# PING data
		# account for missing (no reply) hops
		while [ "$mtr_hopnum" -ge "$((cur_hop_count))" ]; do
			HopPrint "$(printf "%3s. %-90s %10s   %s" "$cur_hop_count" "${white}???${default}" "*" "${white}(No reply)${default}")"
			if [ "$DETAILED_TRACE" = "true" ]; then
				# PWHOIS lookups ON, but no valid data (no reply hop). Just add a newline for readability
				HopPrint ""
			fi
			((cur_hop_count++))
		done
		# data in the array item is the total sum of mtr latencies collected for this hop in microseconds.
		# convert it to milliseconds, and round it to 1 digit precision (mtr's output style)
		ping_total_usec=${pingline_array[$mtr_hopnum]}
		if [ -n "$ping_total_usec" ]; then
			ping_average_msec=$(echo "$ping_total_usec $mtr_rounds" | awk '{ avg = $1 / $2; printf( "%.1f\n", avg/1000) }')
			ping_data="$ping_average_msec ms"
		fi

		[[ -z "$ixp_tag" ]] && hop_color="${white}" || hop_color="${blue}"
		HopPrint "$(printf "%3s. %-90s %10s   %s" "$cur_hop_count" "${hop_color}$hop_ip${default}" "${ping_data}" "$asn_data")"

		if [ "$DETAILED_TRACE" = "true" ] && [ -n "$hop_asn" ]; then
			if [ "$RPKI_LOOKUP" = true ] && [ -n "$found_asname" ]; then # only run RPKI lookups if the prefix is announced
				RPKILookup "$found_asn" "$hop_prefix"
				HopPrint "$(printf "     ├${bluebg}ASN${default} ${red}%s${default} \
					\n     ├${bluebg}ORG${default} ${green}%s${default} \
					\n     ├${bluebg}NET${default} ${yellow}%s${default} \
					\n     ├${bluebg}GEO${default} ${magenta}%s${default} \
					\n     └${bluebg}ROA${default} %s" \
					"$hop_asn" "$hop_org" "$hop_net" "$hop_geo" "$rpki_output")"
					if [ "$INVALID_ROA" = true ]; then
						# notify user of possible BGP hijack/route leak
						aspath_array[-1]+=" ${redbg} ─> WARNING: POSSIBLE ROUTE LEAK / BGP HIJACK ${default}"
					fi
			else
				HopPrint "$(printf "     ├${bluebg}ASN${default} ${red}%s${default} \
					\n     ├${bluebg}ORG${default} ${green}%s${default} \
					\n     ├${bluebg}NET${default} ${yellow}%s${default} \
					\n     └${bluebg}GEO${default} ${magenta}%s${default}" \
					"$hop_asn" "$hop_org" "$hop_net" "$hop_geo")"
			fi
			HopPrint ""
		elif [ "$DETAILED_TRACE" = "true" ]; then
			# PWHOIS lookups ON, but no valid data. Just add a newline for readability
			HopPrint ""
		fi
		[[ "$last_hop" = true ]] && break
		(( cur_hop_count++ ))
	done
	# mtr output (hostlines) parsing complete
	if [ "$last_hop" = false ]; then
		# last hop wasn't our target IP. Add a missing last hop to the trace.
		HopPrint "$(printf "%3s. %-96s %10s   %s" "$cur_hop_count" "${redbg} destination host unreachable ${default}" "*" "${white}(No reply)${default}")"
		[[ "$DETAILED_TRACE" = "true" ]] && HopPrint ""
	fi

	endtime=$(date +%s)
	runtime=$((endtime-starttime))
	StatusbarMessage ""
	echo -e "\nTrace complete in $runtime seconds.\n"

	BoxHeader "AS path to $userinput"
	echo -en "\n  "
	for as in "${aspath_array[@]}"; do
		if [ "$as" = "${aspath_array[0]}" ]; then
			echo -en "${as} ${yellow}(Local AS)${default}"
		else
			echo -en "${as}${default}"
		fi
		if [ "$as" != "${aspath_array[-1]}" ]; then
			echo -en "\n ╭╯\n ╰"
		fi
	done
	echo -e "\n"
}

SearchByOrg(){
	unset orgs
	declare -a orgs
	echo ""
	if [ "$ORG_FILTER" = false ]; then
		StatusbarMessage "Searching for organizations matching ${bluebg}$1${lightgreybg}"
		full_org_search_data=$(whois -h whois.pwhois.org "registry org-name=$1")
		original_organizations=$(echo -e "$full_org_search_data" | grep -E "^Org-Name:" | cut -d ':' -f 2- | sed 's/^ //g' | sort -uf)
		total_orgsearch_results=$(echo -e "$original_organizations" | wc -l)
		organizations="$original_organizations"
	else
		# user chose to apply a search filter to a previous query
		if [ ${#orgfilters_array[@]} -eq 0 ] && [ ${#excl_orgfilters_array[@]} -eq 0 ]; then
			# user deleted all search filters. Revert to original query result
			organizations="$original_organizations"
			ORG_FILTER=false
		else
			StatusbarMessage "Applying filters"
			filtered_org="$original_organizations"
			# parse all inclusion filters
			for filter in "${orgfilters_array[@]}"; do
				apply_filter=$(echo -e "$filtered_org" | grep -i -- "$filter")
				if [ -z "$apply_filter" ]; then
					StatusbarMessage ""
					echo -en "${yellow}Warning: No results found for ${bluebg}${filter}${default}"
					sleep 2
					# remove last filter term
					unset 'orgfilters_array[${#orgfilters_array[@]}-1]'
				else
					filtered_org="$apply_filter"
				fi
			done
			# parse all exclusion filters
			for filter in "${excl_orgfilters_array[@]}"; do
				apply_filter=$(echo -e "$filtered_org" | grep -i -v -- "$filter")
				if [ -z "$apply_filter" ]; then
					StatusbarMessage ""
					echo -en "${yellow}Warning: No more results found if excluding ${bluebg}${filter}${default}"
					sleep 2
					# remove last filter term
					unset 'excl_orgfilters_array[${#excl_orgfilters_array[@]}-1]'
				else
					filtered_org="$apply_filter"
				fi
			done
			# have we removed all filters (because of no matches)? go back to unfiltered results
			if [ ${#orgfilters_array[@]} -eq 0 ] && [ ${#excl_orgfilters_array[@]} -eq 0 ]; then
				ORG_FILTER=false
				echo ""
			fi
			organizations="$filtered_org"
		fi
	fi
	for orgname in $organizations; do
		orgs+=("$orgname")
	done
	StatusbarMessage ""

	if [ ${#orgs[@]} -eq 0 ]; then
		# company search yielded no results
		PrintErrorAndExit "Error: no organizations found"
	fi

	# Menu showing loop
	while true; do
		ShowMenu
		searchresults=""
		[[ "$LOOKUP_ALL_RESULTS" == true ]] && orgs_to_lookup=("${orgs[@]}") || orgs_to_lookup=("$org")
		for org in "${orgs_to_lookup[@]}"; do
			orgids=$(echo -e "$full_org_search_data" | grep -i -E -B1 "Org-Name: $org$" | grep "Org-ID" | cut -d ':' -f 2- | sed 's/^ //g')
			NO_ERROR_ON_INTERRUPT=true
			for ipversion in 4 6; do
				NO_RESULTS=true
				searchresults+=$(BoxHeader "IPv${ipversion} networks for organization \"${org}\"")
				# iterate over Org-IDs related to the company (in case of multiple Org-IDs for a single Org-Name)
				for orgid in $orgids; do
					StatusbarMessage "Looking up IPv${ipversion} networks for organization ${bluebg}$org${lightgreybg} (Org-ID: ${bluebg}${orgid}${lightgreybg})"
					netblocks_output=""
					if [ "$ipversion" = "4" ]; then
						# Parse IPv4 NETBLOCKS
						netblocks=$(whois -h whois.pwhois.org "netblock org-id=${orgid}" | grep -E "^\*>")
						netblocks_header="            IPv4 NET RANGE                | INFO"
						for netblock in $netblocks; do
							prefix=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 1)
							netname=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 2 | tr -d ' ')
							netblock_type=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 3 | tr -d ' ')
							if [ "$netblock_type" = "unknown" ]; then
								nettype=""
							else
								nettype=" (${yellow}$netblock_type${default})"
							fi
							regdate=$(echo -e "$netblock" | cut -d '>' -f 2 | cut -d '|' -f 4 | tr -d ' ')
							if [ "$HAVE_IPCALC" = true ]; then
								# deaggregate IPv4 netblocks into CIDR prefixes for readability
								prefix_spacing=19
								trimmed_prefix=$(echo "$prefix" | tr -d ' ')
								prefix=$(ipcalc -r "$trimmed_prefix" | grep -A1 "deaggregate" | tail -n 1)
							else
								# no ipcalc, use direct pWhois output
								prefix_spacing=41
							fi
							netblocks_output+=$(printf "\n${blue}%${prefix_spacing}s${default} | ${green}%-45s${default} - Registered: ${magenta}%s${default}%s" "$prefix" "$netname" "$regdate" "$nettype")
						done
						[[ "$HAVE_IPCALC" = true ]] && netblocks_header="    IPv4 PREFIX     |       INFO"
					else
						# Parse IPv6 NETBLOCKS
						netblocks=$(whois -h whois.pwhois.org "netblock6 org-id=${orgid}" | grep -E "^Net-(Range|Name|Handle|Type)|^Register-Date" |\
							cut -d ':' -f 2- |\
							sed 's/^ //g' |\
							awk '{if (NR%5) {ORS=""} else {ORS="\n"}{print $0"|"}}') # cheers https://stackoverflow.com/a/35315421/5377165
						netblocks_header="                       IPv6 NET RANGE                         | INFO"
						for netblock in $netblocks; do
							prefix=$(echo -e "$netblock" | cut -d '|' -f 1)
							netname=$(echo -e "$netblock" | cut -d '|' -f 2)
							nethandle=$(echo -e "$netblock" | cut -d '|' -f 3)
							netname+=" (${nethandle})"
							netblock_type=$(echo -e "$netblock" | cut -d '|' -f 4)
							if [ "$netblock_type" = "unknown" ]; then
								nettype=""
							else
								nettype=" (${yellow}$netblock_type${default})"
							fi
							regdate=$(echo -e "$netblock" | cut -d '|' -f 5)
							prefix_spacing=61
							netblocks_output+=$(printf "\n${blue}%${prefix_spacing}s${default} | ${green}%-45s${default} - Registered: ${magenta}%s${default}%s" "$prefix" "$netname" "$regdate" "$nettype")
						done
					fi
					if [ -n "$netblocks_output" ]; then
						# Print out netblocks
						NO_RESULTS=false
						searchresults+=$(echo -e "\n${red}Org-ID: ${magenta}${orgid}${red}${default}\n${netblocks_header}${netblocks_output}")
						searchresults+="\n"
					fi
				done
				[[ "$NO_RESULTS" = "true" ]] && searchresults+="\n\t${red}No results found${default}\n"
			done
		done
		NO_ERROR_ON_INTERRUPT=false
		StatusbarMessage ""
		echo -e "$searchresults\n${yellow}────────────────────────────────────────────────────${default}"
		# let the user choose if they want to run a quick IP lookup
		while true; do
			echo -e "\n- Enter any ${blue}IP/Prefix${default} to look it up or"
			echo -e "- Press ${yellow}ENTER${default} to return to the menu:\n"
			echo -n ">> "
			read -r choice
			# check if it's an IPv4/IPv6
			if [ -n "${choice}" ]; then
				input=$(echo "$choice" | sed 's/\/.*//g' | grep -Eo "$ipv4v6regex")
				if [ -n "$input" ]; then
					# valid IP
					echo ""
					StatusbarMessage "Looking up data for ${bluebg}${input}${lightgreybg}"
					LookupASNAndRouteFromIP "$input"
					(( longest=${#input}+1 ))
					WhoisIP "$input"
					[[ "$REPUTATION_LOOKUP" = true ]] && ReputationLookup "$input"
					StatusbarMessage ""
					continue
				else
					continue
				fi
			else
				# user pressed ENTER, go back to main organizations menu
				clear
				break
			fi
		done
	done
}

ShowMenu(){ # show selection menu for search-by-company results
	clear
	BoxHeader "Organizations matching \"$userinput\""
	if [ "$ORG_FILTER" = true ]; then
		num_inclusion_filters="${#orgfilters_array[@]}"
		num_exclusion_filters="${#excl_orgfilters_array[@]}"
		num_filters=$(( num_inclusion_filters+num_exclusion_filters ))
		[[ $num_filters = 1 ]] && s="" || s="s"
		ACTIVE_FILTERS_STRING=$'\n'"${bluebg}${black}${num_filters} Active filter${s}:${default}"

		# recap inclusion filters
		for filter in "${orgfilters_array[@]}"; do
			ACTIVE_FILTERS_STRING+=" ${lightgreybg}${filter}${default}"
		done

		# recap exclusion filters
		for filter in "${excl_orgfilters_array[@]}"; do
			ACTIVE_FILTERS_STRING+=" ${lightgreybg}${red}-${filter}${default}"
		done

		ACTIVE_FILTERS_STRING+=$'\n'
	else
		ACTIVE_FILTERS_STRING=""
	fi
	if [ "$HAVE_IPCALC" = true ]; then
		IPCALC_WARNING=""
	else
		IPCALC_WARNING=$'\n'"${yellow}Warning: program ${red}ipcalc${yellow} not found."$'\n'"Install it with ${green}apt install ipcalc${yellow}"$'\n'"to enable netblock->CIDR prefix aggregation.${default}"$'\n'
	fi
	PS3="${yellow}────────────────────────────────────────────────────${default}
$ACTIVE_FILTERS_STRING
${yellow}${#orgs[@]} of $total_orgsearch_results total results shown${default}

Choose an organization or enter:
- <${green}text${default}> to FILTER FOR A STRING
- <${blue}-${default}> to EXCLUDE A STRING
- <${blue}x${default}> to REMOVE ALL FILTERS
- <${blue}a${default}> to LOOKUP ALL RESULTS (max 10)
- <${blue}q${default}> to QUIT
$IPCALC_WARNING
>> "
	echo -e "${yellow}────────────────────────────────────────────────────${green}"
	COLUMNS=1
	set -o posix
	select choice in "${orgs[@]}"; do
		for org in "${orgs[@]}"; do
			if [[ "$org" = "$choice" ]]; then
				LOOKUP_ALL_RESULTS=false
				break 2
			fi
		done
		case "$REPLY" in
			"q"|"Q")
				echo ""
				exit 0
			;;
			"-")
				# add an exclusion filter
				echo -n "Enter a string to ${red}exclude${default}: "
				read -r exclusion_string
				excl_orgfilters_array+=("$exclusion_string")
				ORG_FILTER=true
				SearchByOrg
			;;
			"x"|"X")
				# reset filters
				if [ "$ORG_FILTER" = true ]; then
					unset orgfilters_array
					unset excl_orgfilters_array
					declare -a orgfilters_array
					declare -a excl_orgfilters_array
					SearchByOrg
				fi
			;;
			"a"|"A")
				# lookup all results
				if [ "${#orgs[@]}" -gt 10 ]; then
					echo -en "\n${redbg}Too many results! Please add some filters!${default}\n"
					sleep 2
					continue
				fi
				LOOKUP_ALL_RESULTS=true
				break
			;;
			*)
				# apply filter to the results
				orgfilters_array+=("$REPLY")
				ORG_FILTER=true
				SearchByOrg
			;;
		esac
	done
	set +o posix
	echo ""
}

SignalsAPIQuery(){ # output saved to $signals_response
	signals_response=""
	# Authenticate to Auth0 Signals API, otherwise run anonymously
	if [ -n "$SIGNALS_TOKEN" ]; then
		signals_response=$(curl -s --request GET --url "$1" --header "accept: application/json" --header "x-auth-token: ${SIGNALS_TOKEN}")
	else
		signals_response=$(curl -s --request GET --url "$1" --header "accept: application/json")
	fi
	# check Signals output to make sure we didn't receive invalid data (eg. quota exceeded etc)
	# if it's not valid json...
	is_valid_json=$(echo "$signals_response" | jq type 2>/dev/null)
	if [ -z "$is_valid_json" ]; then
		# ...and it's not a "clean ip" reply...
		if echo "$signals_response" | grep -vq "Resource not found"; then
			# then fail
			StatusbarMessage ""
			server_errormsg="$signals_response"
			signals_response="${redbg}ERROR: Could not query Signals API${default} (Server said: \"${server_errormsg}\")"
			REPUTATION_LOOKUP=false
		fi
	fi
}

ReputationLookup(){
	# invoking with "ReputationLookup <ip> no_details" turns off detailed blacklist report
	[[ "$2" == "no_details" ]] && DETAILED_REPORT=false || DETAILED_REPORT=true
	StatusbarMessage "Looking up reputation for IP address ${bluebg}$1${lightgreybg}"
	SignalsAPIQuery "https://signals.api.auth0.com/badip/$1"
	StatusbarMessage ""
	if [ "$REPUTATION_LOOKUP" = false ]; then
		# we hit an error during last Signals API query, notify and move on
		IS_BADIP=false
		badip_output="$signals_response"
	elif echo "$signals_response" | grep -q "Resource not found"; then
		IS_BADIP=false
		badip_output="${green}✓ GOOD${default}"
	else
		IS_BADIP=true
		black_count=$(echo "$signals_response" | jq '.response | length')
		[[ "$black_count" -gt 1 ]] && s="s" || s=""
		badip_output="${red}❌ BAD${default}"
	fi
	printf "${white}%${indent}s${bluebg}REP${default} ${magenta}%s${default}\n\n" "└" "$badip_output"
	if [ "$IS_BADIP" = false ]; then
		return
	fi
	badip_output="${red}❌ BAD (Address found in ${black_count} blacklist${s})${default}"
	if [ "$DETAILED_REPORT" = true ]; then
		BoxHeader "Detailed IP reputation report for $1"
		echo ""
		# parse blacklists and collect bad tags associated with the IP address
		echo -e "${bluebg} IP ADDRESS────>${default} ${white}$1"
		echo -e "${bluebg} REPUTATION────>${default} $badip_output"
		StatusbarMessage "Collecting detailed reputation data"
		global_tags=""
		blacklist_output=""
		blacklists=$(echo "$signals_response" | jq -r '.response[]')
		for blacklist in $(echo "$blacklists" | sort); do
			SignalsAPIQuery "https://signals.api.auth0.com/metadata/badip/lists/$blacklist"
			if [ "$REPUTATION_LOOKUP" = false ]; then
				# we hit an error during last Signals API query, notify and move on
				StatusbarMessage ""
				echo -e "$signals_response\n\n"
				return
			fi
			blacklist_details="$signals_response"
			name=$(echo "$blacklist_details" | jq -r '.name')
			group=$(echo "$blacklist_details" | jq -r '.group')
			site=$(echo "$blacklist_details" | jq -r '.site')
			tags=$(echo "$blacklist_details" | jq -r '.tags')
			[[ -z "$global_tags" ]] && global_tags="$tags" || global_tags+=",$tags"
			blacklist_output+="${bluebg} BLACKLIST HIT─>${default} ${red}[$group] ${yellow}${blacklist} (${name} -- ${blue}${site}${yellow})\n"
		done
		StatusbarMessage ""
		unique_tags=$(echo "$global_tags" | tr ',' '\n' | sort -u  | tr '[:lower:]' '[:upper:]')
		output_tags=""
		for tag in $unique_tags; do output_tags+="${redbg} ${tag} ${default} "; done
		echo -e "${bluebg} ABUSE TAGS────>${default} ${output_tags}"
		echo -e "${blacklist_output}"
	fi
}

RPKILookup(){
	# $1=asn, $2=prefix
	found_rpkivalidity=""
	INVALID_ROA=false
	rpki_apioutput=$(curl -s "https://rpki-validator.ripe.net/api/bgp/validity/?asn=$1&prefix=$2")
	is_valid_json=$(echo "$rpki_apioutput" | jq type 2>/dev/null)
	if [ -n "$is_valid_json" ]; then
		found_rpkivalidity=$(echo "$rpki_apioutput" | jq -r '.data.validity')
		found_rpkiroacount=$(echo "$rpki_apioutput" | jq -r '.metadata.totalCount')
		found_rpkiorigin=$(echo "$rpki_apioutput" | jq -r '.data.validatingRoas[0].origin')
		found_rpkiprefix=$(echo "$rpki_apioutput" | jq -r '.data.validatingRoas[0].prefix')
		found_rpkimaxlength=$(echo "$rpki_apioutput" | jq -r '.data.validatingRoas[0].maxLength')
		# TODO: iterate over ROAs (.data.validatingRoas[]) to give deeper source RIR insight
		#found_rpkisource=$(echo "$rpki_apioutput" | jq -r '.data.validatingRoas[0].source')
		case "$found_rpkivalidity" in
			"VALID")
				[[ "${found_rpkiroacount}" -gt 1 ]] && s="s" || s=""
				rpki_output="${green}✓ VALID (${found_rpkiroacount} ROA$s found)${default}"
				;;
			"UNKNOWN")
				rpki_output="✓ UNKNOWN"
				;;
			"INVALID_ASN")
				INVALID_ROA=true
				if [ "$found_rpkiorigin" = "0" ]; then
					rpki_output="${red}❌ ${found_rpkivalidity} (no Origin authorized to announce Prefix '${found_rpkiprefix}' with Max-Length=${found_rpkimaxlength})${default}"
				else
					rpki_output="${red}❌ ${found_rpkivalidity} (expected Origin ${found_rpkiorigin} for Prefix '${found_rpkiprefix}' with Max-Length=${found_rpkimaxlength})${default}"
				fi
				;;
			"INVALID_LENGTH")
				INVALID_ROA=true
				rpki_output="${red}❌ ${found_rpkivalidity} (expected Max-Length=${found_rpkimaxlength} for Prefix '${found_rpkiprefix}')${default}"
				;;
		esac
	else
		rpki_output="${yellow}? (WRONG RPKI DATA, invalid prefix?)${default}"
	fi
}

IsIXP() {
	# input ($1) is an IPv4/v6.
	ixp_full_ix_data=""
	ixp_data=""
	ixp_geo=""
	if [ "$IXP_DETECTION" = true ]; then
		# Update IXP prefixes from PeeringDB if necessary
		[[ -z "$peeringdb_dataset" ]] && peeringdb_dataset=$(curl -s https://www.peeringdb.com/api/ixpfx)
		ixp_prefixes=$(echo -e "$peeringdb_dataset" | jq -r '.data[].prefix')
		if echo -e "$ixp_prefixes" | grep -vq ':'; then
			# if input is an IPv4, speedup grepcidr lookup by filtering out IPv6 IXP prefixes
			ipv4_prefixes=$(echo -e "$ixp_prefixes" | grep -v ':')
			ixp_prefixes="$ipv4_prefixes"
		fi
		for prefix in $ixp_prefixes; do
			if echo "$1" | grepcidr -f <(echo "$prefix") &>/dev/null; then
				# the IP is part of an IXP prefix
				# Query PeeringDB to match an IXP for that prefix.
				ixlan_id=$(echo "$peeringdb_dataset" | jq -r '.data[] | select(.prefix == "'"$prefix"'") | .ixlan_id')
				ixp_full_ix_data=$(curl -s "https://www.peeringdb.com/api/ix/$ixlan_id")
				ixp_data=$(echo "$ixp_full_ix_data" | jq -r '.data[0].name, .data[0].name_long' | paste -sd '|' - | awk -F'|' '{print $1 " (" $2 ")"}')
				ixp_geo=$(echo "$ixp_full_ix_data" | jq -r '.data[0].org.city, .data[0].org.state' | paste -sd '|' - | awk -F'|' '{print $1 " (" $2 ")"}')
				break
			fi
		done
	fi
}

PrintErrorAndExit(){
	echo -e "\n${redbg}${1}${default}\n"
	tput sgr0
	exit 1
}

Ctrl_C() {
	if [ "$NO_ERROR_ON_INTERRUPT" = true ]; then
		StatusbarMessage ""
		tput sgr0
		ShowMenu
	else
		PrintErrorAndExit "Interrupted"
	fi
}

BoxHeader() { # cheers https://unix.stackexchange.com/a/70616
	local s="$*"
	echo -e "\n${white}╭─${s//?/─}─╮
│ ${yellow}${s}${white} │
╰─${s//?/─}─╯"
	tput sgr 0
}

StatusbarMessage() { # invoke without parameters to delete the status bar message
	if [ -n "$statusbar_message" ]; then
		# delete previous status bar message
		printf "\r%${#statusbar_message}s\r" " "
	fi
	if [ -n "$1" ]; then
		statusbar_message="${lightgreybg}$1 (press CTRL-C to cancel)...${default}"
		echo -en "$statusbar_message"
	fi
}

WhatIsMyIP() {
	# only lookup local WAN IP once
	[[ -n "$local_wanip" ]] && return
	# retrieve local WAN IP (v6 takes precedence) from ipify
	local_wanip=$(curl -s api64.ipify.org)
	# check if we default to an IPv6 internet connection
	if echo "$local_wanip" | grep -q ':'; then
		HAVE_IPV6=true
	fi
}

CheckPrerequisites() {
	saveIFS="$IFS"
	IFS=' '
	prerequisite_tools="coproc whois host curl" # mandatory tools
	optionals_tools="mtr jq ipcalc grepcidr"	# optional tools
	missing_tools=""
	disabled_features=""
	HARD_FAIL=false

	RIPESTAT_LOOKUP=true
	RPKI_LOOKUP=true
	REPUTATION_LOOKUP=true
	HAVE_IPCALC=true
	IXP_DETECTION=true

	#* Mandatory tools checking (hard fail if not found)
	for tool in $prerequisite_tools; do
		if [ -z "$(command -v "$tool")" ]; then
			missing_tools+="\n - $tool"
			HARD_FAIL=true
		fi
	done

	#* Optional tools checking (no hard fail if not found, but some features disabled)
	for tool in $optionals_tools; do
		if [ -z "$(command -v "$tool")" ]; then
			missing_tools+="\n - $tool"
			case "$tool" in
				"mtr")
					disabled_feat="AS path tracing"
					TRACEASNPATH=false
					;;
				"jq")
					disabled_feat="IP reputation, RIPEstat BGP info / ASN suggestions, and RPKI ROA lookups"
					RIPESTAT_LOOKUP=false
					RPKI_LOOKUP=false
					REPUTATION_LOOKUP=false
					;;
				"ipcalc")
					disabled_feat="CIDR deaggregation"
					HAVE_IPCALC=false
					;;
				"grepcidr")
					disabled_feat="IXP prefix detection"
					IXP_DETECTION=false
					;;
			esac

			disabled_features+="\n - ${disabled_feat}"
		fi
	done

	if [ -n "$missing_tools" ]; then
		BoxHeader "! WARNING !"
		echo -e "\nThe following tools were not found on this system:" \
				"${red} ${missing_tools}${default}"

		if [ -n "$disabled_features" ]; then
			echo -e "\nThe following features will be disabled:" \
					"${yellow}${disabled_features}${default}"
		fi

		echo -e "\nPlease install the necessary prerequisite packages\nfor your system by following these instructions:" \
				"\n\n>> ${blue}https://github.com/nitefood/asn#prerequisite-packages${default} <<\n"

		[[ "$HARD_FAIL" = true ]] && PrintErrorAndExit "Can not continue without (at least) the following tools: ${prerequisite_tools// /, }"

		echo -n "${lightgreybg}Press ENTER to continue...${default}"
		# shellcheck disable=SC2034
		read -r key
	fi

	if [ "$REPUTATION_LOOKUP" = true ]; then
		# Read Auth0 Signals (IP reputation API) token from file
		SIGNALS_TOKEN=""
		if [ -r "$SIGNALS_TOKEN_FILENAME" ]; then
			SIGNALS_TOKEN=$(tr -d ' \n\r\t' < "$SIGNALS_TOKEN_FILENAME")
		fi
		if [ -z "$SIGNALS_TOKEN" ]; then
			# warn the user about the limits of anonymous Signals queries
			echo -en "\n${yellow}────────────────────────────────────────────────────────────\n\t\t\tWARNING${default}" \
				"\n\nNo Auth0 Signals token found, so running anonymously.\n\nConsider registering at" \
				"${blue}https://auth0.com/signals/api/signup${default}\nto obtain a free token and increase" \
				"your IP reputation\nquery limit from 100 hits/day to 40000 hits/day.\n\nAfter getting your API token, copy and paste it inside" \
				"\n${green}$SIGNALS_TOKEN_FILENAME${default} and it will be used automatically." \
				"\n${yellow}────────────────────────────────────────────────────────────${default}\n"
		fi
	fi

	# check for `gdate` presence (MacOS coreutils), otherwise fall back to plain `date` (cheers @Antonio-Prado)
	if [ -x "$(command -v gdate)" ]; then
		date() { gdate "$@"; }
		export -f date
	fi

	IFS="$saveIFS"
}

# Color scheme
IFS=$'\n\t'
green=$'\e[32m'
magenta=$'\e[35m'
yellow=$'\e[33m'
white=$'\e[97m'
blue=$'\e[94m'
red=$'\e[31m'
black=$'\e[30m'
lightgreybg=$'\e[47m\e[30m'
bluebg=$'\e[44m\e[30m'
redbg=$'\e[30m\e[101m'
greenbg=$'\e[42m\e[30m'
yellowbg=$'\e[43m\e[30m'
default=$'\e[0m'

# External API token for Auth0 Signals (IP reputation lookup)
SIGNALS_TOKEN_FILENAME="$HOME/.asn/signals_token"

# PeeringDB list of IXP prefixes
peeringdb_dataset=""

# Sigint trapping
NO_ERROR_ON_INTERRUPT=false
trap Ctrl_C INT

ipv4v6regex='[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}|(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|'\
'([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|'\
'([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|'\
':((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|'\
'(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|'\
'1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))' # cheers https://stackoverflow.com/a/17871737

# Check cmdline parameters
if [[ $# -lt 1 ]]; then
	PrintUsage
	exit 1
fi

FORCE_ORGSEARCH=false
SUGGEST_SEARCH=false

case "$1" in
	"-n"|"--notrace")
		if [[ $# -lt 2 ]]; then
			PrintUsage
			echo -e "Error: missing ${red}TARGET${default}\n"
			exit 1
		fi
		TRACEASNPATH=false
		DETAILED_TRACE=false
		userinput="$2"
		;;
	"-d"|"--detailed")
		if [[ $# -lt 2 ]]; then
			PrintUsage
			echo -e "Error: missing ${red}TARGET${default}\n"
			exit 1
		fi
		TRACEASNPATH=true
		DETAILED_TRACE=true
		userinput="$2"
		;;
	"-o"|"--organization")
		if [[ $# -lt 2 ]]; then
			PrintUsage
			echo -e "Error: missing ${red}TARGET${default}\n"
			exit 1
		else
			FORCE_ORGSEARCH=true
			userinput=$(echo "$@" | cut -d ' ' -f 2- | sed -e 's/^[ \t]*//')
		fi
		;;
	"-s"|"--suggest")
		if [[ $# -lt 2 ]]; then
			PrintUsage
			echo -e "Error: missing ${red}TARGET${default}\n"
			exit 1
		else
			SUGGEST_SEARCH=true
			userinput=$(echo "$@" | cut -d ' ' -f 2- | sed -e 's/^[ \t]*//')
		fi
		;;
	*)
		if [ "${1:0:1}" = "-" ]; then
			 PrintUsage
			 echo -e "Error: unknown option ${red}$1${default}\n"
			 exit 1
		else
			# defaults
			TRACEASNPATH=true
			DETAILED_TRACE=false
			ENABLE_ORGSEARCH=true
			# shellcheck disable=2124
			userinput="$@"
		fi
		;;
esac

#* Check prerequisite and optional tools
CheckPrerequisites

local_wanip=""
HAVE_IPV6=false
BoxHeader "ASN lookup for $userinput"

if [ "$FORCE_ORGSEARCH" = true ]; then
	# user passed the "-o|--organization" switch
	ORG_FILTER=false
	declare -a orgfilters_array
	declare -a excl_orgfilters_array
	SearchByOrg "$userinput"
	exit 0
fi

if [ "$SUGGEST_SEARCH" = true ]; then
	# user passed the "-s|--suggest" switch
	[[ "$RIPESTAT_LOOKUP" = false ]] &&	PrintErrorAndExit "Please install the necessary prerequisite tool!"
	RIPESuggestASN "$userinput"
	exit 0
fi


input=$(echo "$userinput" | sed 's/\/.*//g' | grep -Eo "$ipv4v6regex")

if [ -z "$input" ]; then
	# Input is not an IP Address. Check if it is a number (ASN)
	asn=$(echo "$userinput" | sed 's/[a|A][s|S]//g' | grep -E "^[0-9]*$")
	if [ -z "$asn" ]; then
		# Input is not an ASN either. See if it's a hostname (includes at least one dot)
		if echo "$userinput" | grep -q "\."; then
			echo -e -n "\n${blue}- Resolving \"$userinput\"... "
			ip=$(ResolveHostnameToIPList "$userinput")
			if [ -z "$ip" ]; then
				echo -e "${red}Error: unable to resolve hostname${default}" \
						"\n\n(Hint: if you wanted to search by organization, try the ${blue}'-o'${default} switch)\n"
				exit 1
			fi
			numips=$(echo "$ip" | wc -l)
			[[ $numips = 1 ]] && s="" || s="es"
			echo -e "${blue}$numips IP address$s found:\n"
			# grab the longest IP to properly size output padding
			longest=0
			for singleip in $ip; do
				[[ ${#singleip} -gt $longest ]] && longest=${#singleip}
			done
			(( longest++ ))
			# output actual results
			ip_to_trace=""
			WhatIsMyIP
			for singleip in $ip; do
				LookupASNAndRouteFromIP "$singleip"
				WhoisIP "$singleip"
				if [ "$REPUTATION_LOOKUP" = true ]; then
					if [ "$numips" = 1 ]; then
						ReputationLookup "$singleip"
					else
						ReputationLookup "$singleip" no_details
					fi
				fi
				# save the first IP from the dns lookup result
				[[ -z "$ip_to_trace" ]] && ip_to_trace="$singleip"
			done
			# Check if AS path tracing is requested
			if [ "$TRACEASNPATH" = true ]; then
				# In case of multiple IPs (DNS RR), trace the first one.
				# Additionally, if we're on an IPv6 connection, default to
				# tracing to the first resolved IPv6 address (if any)
				if [ "$HAVE_IPV6" = true ]; then
					first_ipv6=$(echo "$ip" | grep -m1 ':')
					[[ -n "$first_ipv6" ]] && ip_to_trace="$first_ipv6"
				fi
				TraceASPath "$ip_to_trace"
			fi
			tput sgr0
			echo ""
			exit 0
		else
			# not an IP, not an ASN, not a hostname. Consider it an Organization name unless a cmdline option was specified
			[[ -z "$ENABLE_ORGSEARCH" ]] && PrintErrorAndExit "Error: To search by organization, please pass the [-o|--organization] command line switch (or no switch at all)"
			ORG_FILTER=false
			declare -a orgfilters_array
			declare -a excl_orgfilters_array
			SearchByOrg "$userinput"
		fi
	else
		# Input is an ASN
		WhoisASN "$asn"
		if [ -z "$found_asname" ]; then
			PrintErrorAndExit "Error: no data found for AS${asn}"
		fi
		echo -e "\n${bluebg} AS Number ──────>${default} ${red}${asn}"
		echo -e "${bluebg} AS Name ────────>${default} ${green}${found_asname}"
		echo -e "${bluebg} Organization ───>${default} ${yellow}${found_org}"
		echo -e "${bluebg} AS Reg. date ───>${default} ${white}${found_createdate}"
		if [ "$RIPESTAT_LOOKUP" = true ]; then
			BoxHeader "BGP informations for AS${asn} (${found_asname})"
			echo ""
			QueryRipestat "${asn}"
			if [ -n "$ripestat_routing_data" ]; then
				echo -e "${bluebg} IPv4 Prefixes ─────>${default} ${green}${ripestat_ipv4}"
				echo -e "${bluebg} IPv6 Prefixes ─────>${default} ${yellow}${ripestat_ipv6}"
				echo -e "${bluebg} BGP Neighbours ────>${default} ${blue}${ripestat_bgp}${default}"
			fi
			if [ -n "$ripestat_neighbours_data" ]; then
				[[ -n "$upstream_peers" ]] && upstream_peers=$(echo -e "$upstream_peers") || upstream_peers="${redbg} NONE ${default}"
				[[ -n "$downstream_peers" ]] && downstream_peers=$(echo -e "$downstream_peers") || downstream_peers="${redbg} NONE ${default}"
				[[ -n "$uncertain_peers" ]] && uncertain_peers=$(echo -e "$uncertain_peers") || uncertain_peers="${redbg} NONE ${default}"
				BoxHeader "Peering informations for AS${asn} (${found_asname})"
				echo -e "\n${green}──────────────── Upstream Peers ────────────────${default}\n\n${upstream_peers}"
				echo -e "\n${yellow}─────────────── Downstream Peers ───────────────${default}\n\n${downstream_peers}"
				echo -e "\n${white}─────────────── Uncertain  Peers ───────────────${default}\n\n${uncertain_peers}\n"
			fi
			BoxHeader "Announced prefixes (aggregated) for AS${asn} (${found_asname})"
			echo -e "\n${green}───── IPv4 ─────${default}"
			[[ -n "$ipv4_inetnums" ]] && echo -e "${green}${ipv4_inetnums}${default}" || echo -e "\n${redbg} NONE ${default}"
			echo -e "\n${yellow}───── IPv6 ─────${default}"
			[[ -n "$ipv6_inetnums" ]] && echo -e "${yellow}${ipv6_inetnums}${default}" || echo -e "\n${redbg} NONE ${default}"
		fi
		tput sgr0
		echo ""
		exit 0
	fi
else
	# Input is an IP address
	# Perform IP lookup
	LookupASNAndRouteFromIP "$input"
	(( longest=${#input}+1 ))
	WhoisIP "$input"
	# Perform reputation lookup if requested
	[[ "$REPUTATION_LOOKUP" = true ]] && ReputationLookup "$input"
	# Perform AS path tracing if requested
	[[ "$TRACEASNPATH" = true ]] && TraceASPath "$input"
	tput sgr0
	echo ""
	exit 0
fi
